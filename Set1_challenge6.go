package cryptopals_challenges_go

import "math/bits"

func hammingDistanceByte(left byte, right byte) int {
	distance := 0
	xoredInput := left ^ right
	for xoredInput > 0 {
		xoredInput &= xoredInput - 1;
		distance += 1
	}
 	return distance
}

func hammingDistance(left []byte, right []byte) int {
	if len(left) != len(right) {
		panic("Can not calculate hamming distance between unequal arrays")
	}
	distance := 0
	for i := 0; i < len(left); i += 1 {
		distance += hammingDistanceByte(left[i], right[i])
	}
	return distance
}

func calculateKeySizes(input []byte, maxKeySize int) []float32 {
	if maxKeySize > (len(input) / 2) {
		panic("Max key size may not be greater than input length")
	}
	results := make([]float32, maxKeySize)
    for i := 1; i <= maxKeySize; i += 1 {
    	dist1 := float32(hammingDistance(input[0:i], input[i: i * 2])) / float32(i + 1)
    	dist2 := float32(hammingDistance(input[i * 2: i * 3], input[i * 3: i * 4])) / float32(i + 1)
		results[i - 1] = (dist1 + dist2) / 2
	}
	return results
}

func transposeBlocks(input []byte, keySize int) [][]byte {
	dst := make([][]byte, keySize)
	for keyPosition := 0; keyPosition < keySize; keyPosition = keyPosition + 1 {
		if keyPosition < (len(input) % keySize) {
			dst[keyPosition] = make([]byte, (len(input) / keySize) + 1)
		} else {
			dst[keyPosition] = make([]byte, len(input) / keySize)
		}
	}
	for i, j := 0, 1; i < len(input); i, j = i + 1, j + 1 {
		dst[i % keySize][int(i / keySize)] = input[i]
	}
	return dst
}

var rcon = [256]byte {
	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
	0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
	0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
	0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
	0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
	0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
	0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
	0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
	0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d,
}

func keyScheduleCore(in uint32, i int) uint32 {
	out := in
	bits.RotateLeft32(out, 8)
}

func expand_key(key []byte, n int, b int)[]byte {
	dst := make([]byte, b)
	keySize := len(key)
	dst[0:len(key)] = key
	loopCount := (b - keySize) / keySize
	i := 1
	for j := 1; j <= loopCount; j++ {
		t := make([]byte, 4)
		t[0:] = dst[(keySize * j) - 4: keySize * j]
		keyScheduleCore(uint32(t[0]) << 24 & uint32(t[1]) << 16 & uint32(t[2]) << 8 & uint32(t[3]), i)
	}
	return dst
}

func expand_key_128(key []byte) []byte {
	n := 16
	b := 176
	return expand_key(key, n, b)
}

func decrypt_aes_128_ecb(input []byte, key []byte) []byte {
	return make([]byte, 0)
}
